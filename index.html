<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Âπ∏ËøêÂ§ßËΩ¨Áõòüí∞</title>
  <meta name="description" content="ÁßªÂä®‰ºòÂÖàÂπ∏ËøêËΩ¨Áõò ‚Äî ÈöèÊú∫ÊäΩÂèñ 1-49 ÁöÑÂπ∏ËøêÊï∞Â≠ó" />
  
  <link rel="icon" href="/favicon.ico?v=2">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#ffb86b">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#ffb86b">
  <style>
    :root{
      --bg:#071022;
      --card: rgba(255,255,255,0.02);
      --accent:#ffb86b;
      --muted:#9fb0c8;
      --text:#eef6ff;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(800px 300px at 10% 10%, rgba(255,184,107,0.04), transparent), var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
    }

    .app {
      width:100%;
      max-width:980px;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:20px;
      align-items:start;
    }
    @media (max-width:820px){
      .app{grid-template-columns:1fr; padding-bottom:18px}
    }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:14px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.02);
    }

    .left{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }

    .wheel-wrap{
      width:100%;
      max-width:520px;
      aspect-ratio:1/1;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action:manipulation;
    }

    canvas#wheelCanvas{
      width:100%;
      height:100%;
      border-radius:50%;
      background: conic-gradient( rgba(255,255,255,0.02), transparent 180deg );
      box-shadow: 0 12px 36px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      -webkit-tap-highlight-color: transparent;
    }

    /* top pointer */
    .pointer {
      position:absolute;
      top:6px;
      left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:14px solid transparent;
      border-right:14px solid transparent;
      border-bottom:32px solid var(--accent);
      filter:drop-shadow(0 6px 10px rgba(0,0,0,0.6));
      z-index:40;
    }

    /* center display: ensure clarity on small screens */
    .center {
      position:absolute;
      width:132px;
      height:132px;
      border-radius:50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      z-index:45;
      box-shadow: 0 8px 24px rgba(2,6,23,0.6);
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      border:1px solid rgba(255,255,255,0.03);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
    }

    .result {
      font-size:34px;
      font-weight:800;
      color:var(--accent);
      line-height:1;
      letter-spacing:1px;
    }
    .sub {
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }

    .controls {
      display:flex;
      gap:12px;
      margin-top:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    button.btn {
      padding:12px 18px;
      border-radius:12px;
      border: none;
      cursor:pointer;
      font-weight:700;
      color:#071022;
      background: linear-gradient(180deg,var(--accent), #ff9d3a);
      box-shadow: 0 8px 24px rgba(255,153,66,0.12);
      transition: transform 0.12s ease, filter 0.12s ease;
      min-width:96px;
      font-size:16px;
    }
    button.btn.secondary{
      background:transparent;
      color:var(--accent);
      border: 1px solid rgba(255,184,107,0.12);
      box-shadow:none;
    }
    button.btn:active{transform:translateY(1px)}
    button.btn[disabled]{opacity:0.45;cursor:not-allowed}

    .right{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .title{display:flex;justify-content:space-between;align-items:center}
    .title h2{margin:0;font-size:16px}
    .small{font-size:13px;color:var(--muted)}
    .history{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      padding:10px;
      border-radius:10px;
      background: rgba(255,255,255,0.02);
      min-height:66px;
      align-items:center;
    }
    .history .item{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:8px 12px;
      border-radius:999px;
      color:#fff;
      font-weight:800;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
      border:1px solid rgba(255,255,255,0.02);
      font-size:15px;
    }
    .meta{display:flex;gap:10px;align-items:center}
    .message{min-height:36px;color:#ffdca8;font-weight:700}
    .footer-note{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <main class="app">
    <section class="panel left">
      <div class="wheel-wrap" id="wheelWrap" aria-hidden="false">
        <canvas id="wheelCanvas" width="800" height="800" role="img" aria-label="Âπ∏ËøêËΩ¨Áõò"></canvas>
        <div class="pointer" aria-hidden="true"></div>
        <div class="center" role="status" aria-live="polite">
          <div class="result" id="result">?</div>
          <div class="sub">‰∏≠Â•ñÂè∑Á†Å</div>
        </div>
      </div>

      <div style="width:100%;display:flex;justify-content:center;">
        <div class="controls">
          <button class="btn" id="spinBtn" aria-label="ÂºÄÂßãÊäΩÂ•ñ">ÂºÄÂßã</button>
          <button class="btn secondary" id="resetBtn" aria-label="ÈáçÁΩÆÂéÜÂè≤">ÈáçÁΩÆ</button>
          <div class="small" style="align-self:center">Ââ©‰ΩôÔºö<strong id="remaining">7</strong>/7</div>
        </div>
      </div>

      <div class="footer-note">ÊîØÊåÅÁ©∫Ê†ºÈîÆËß¶Âèë ¬∑ Ëß¶Â±è‰ºòÂÖà ¬∑ ËØ∑Ê®™ÁΩÆÊàñÊîæÂ§ßÊü•ÁúãÊõ¥Ê∏ÖÊô∞ÁöÑËΩ¨Áõò</div>
    </section>

    <aside class="panel right">
      <div class="title">
        <h2>ÊäΩÂ•ñËÆ∞ÂΩï</h2>
        <div class="small">ÊúÄËøë 7 Ê¨°</div>
      </div>

      <div class="history" id="history">ÊöÇÊó†ËÆ∞ÂΩï</div>

      <div>
        <div class="small">ÊèêÁ§∫</div>
        <div class="message" id="message"></div>
      </div>
    </aside>
  </main>

  <!-- Audio elements: place your audio files at /sounds/spin.mp3 and /sounds/stop.mp3
       - spin.mp3 should be a soft continuous loop (low volume) to play while the wheel spins.
       - stop.mp3 should be a short "impact" or "ding" sound played on stop.
       If you don't have files, the script will fallback to short generated beeps for ticks/stop using WebAudio.
  -->
  <audio id="spinAudio" src="/sounds/spin.mp3" preload="auto" loop></audio>
  <audio id="stopAudio" src="/sounds/stop.mp3" preload="auto"></audio>

  <script>
    // Mobile-friendly improvements and precise alignment of result.
    // Added audio behavior:
    // - spinAudio: looped audio element played while wheel animates (if available and allowed).
    // - stopAudio: played once when animation finishes.
    // - tick sounds: generated via WebAudio when the wheel crosses sectors (fallback / supplement).
    // Note: Mobile browsers require a user gesture to allow AudioContext / play audio. The spin button/canvas click is a user gesture.

    const TOTAL = 49;
    const MAX_SPINS = 7;
    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const spinBtn = document.getElementById('spinBtn');
    const resetBtn = document.getElementById('resetBtn');
    const resultEl = document.getElementById('result');
    const messageEl = document.getElementById('message');
    const historyEl = document.getElementById('history');
    const remainingEl = document.getElementById('remaining');

    const spinAudioElem = document.getElementById('spinAudio');
    const stopAudioElem = document.getElementById('stopAudio');

    let audioCtx = null;
    function getAudioCtx(){
      if (!audioCtx){
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          audioCtx = null;
        }
      }
      return audioCtx;
    }

    // Short generated tick/impact using WebAudio (fallback if stopAudio missing or for per-sector tick)
    function playGeneratedClick({type='tick', volume=0.08} = {}){
      const ac = getAudioCtx();
      if (!ac) return;
      // tiny envelope tone
      const o = ac.createOscillator();
      const g = ac.createGain();
      const now = ac.currentTime;
      if (type === 'tick'){
        o.frequency.value = 1400;
        g.gain.setValueAtTime(volume, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
      } else { // 'stop'
        o.frequency.value = 600;
        g.gain.setValueAtTime(volume, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      }
      o.type = 'sine';
      o.connect(g);
      g.connect(ac.destination);
      o.start(now);
      o.stop(now + (type === 'tick' ? 0.04 : 0.2));
    }

    // try to play an HTMLAudioElement and fall back to generated sound
    async function tryPlayAudioElem(elem, fallbackType='stop'){
      if (!elem) { playGeneratedClick({type: fallbackType}); return; }
      try {
        // resume audio context if suspended (mobile)
        const ac = getAudioCtx();
        if (ac && ac.state === 'suspended') await ac.resume();
        elem.currentTime = 0;
        await elem.play();
      } catch (err) {
        // playback failed (maybe browser blocked), fallback
        playGeneratedClick({type: fallbackType});
      }
    }

    // responsive high-dpi canvas sizing
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    function sizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(200, rect.width);
      const h = Math.max(200, rect.height);
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    sizeCanvas();
    window.addEventListener('resize', () => {
      sizeCanvas();
      drawWheel(currentRotation);
    });

    // state
    let history = JSON.parse(localStorage.getItem('lucky_history')) || [];
    history = Array.isArray(history) ? history : [];
    let spinCount = parseInt(localStorage.getItem('lucky_spinCount')) || 0;
    let isSpinning = false;
    let currentRotation = 0; // degrees, applied clockwise
    const sectorAngle = 360 / TOTAL;

    const colors = [
      '#ff8a65','#ffd54f','#81c784','#4fc3f7','#b39ddb','#ffab91','#ffe082','#aed581',
      '#4dd0e1','#ce93d8','#ffcc80','#fff59d'
    ];

    function drawWheel(rotation = 0) {
      const w = canvas.width / dpr;
      const h = canvas.height / dpr;
      const cx = w/2, cy = h/2;
      const radius = Math.min(w, h)/2 - 6;
      ctx.clearRect(0,0,w,h);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rotation * Math.PI / 180);

      for (let i=0;i<TOTAL;i++){
        const start = (i * sectorAngle - sectorAngle/2) * Math.PI/180;
        const end = ((i+1) * sectorAngle - sectorAngle/2) * Math.PI/180;
        ctx.beginPath();
        ctx.fillStyle = colors[i % colors.length];
        ctx.moveTo(0,0);
        ctx.arc(0,0,radius,start,end,false);
        ctx.closePath();
        ctx.fill();

        // number text: mid-angle for sector i is i * sectorAngle (deg)
        const mid = (i * sectorAngle) * Math.PI/180;
        const textRadius = radius * 0.72;
        ctx.save();
        const tx = Math.cos(mid) * textRadius;
        const ty = Math.sin(mid) * textRadius;
        ctx.translate(tx, ty);
        ctx.rotate(mid + Math.PI/2); // make text upright relative to viewer
        ctx.fillStyle = '#071022';
        ctx.font = `${Math.max(12, Math.floor(radius * 0.095))}px system-ui, Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(i+1), 0, 0);
        ctx.restore();
      }

      // outer ring
      ctx.beginPath();
      ctx.lineWidth = Math.max(3, radius*0.04);
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.arc(0,0, radius + ctx.lineWidth/2 - 1, 0, Math.PI*2);
      ctx.stroke();

      ctx.restore();
    }

    drawWheel(currentRotation);

    function getRandomNumberNotInHistory(){
      const avail = [];
      for (let i=1;i<=TOTAL;i++) if (!history.includes(i)) avail.push(i);
      if (avail.length === 0) return null;
      return avail[Math.floor(Math.random() * avail.length)];
    }

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // compute desired final rotation (deg) so that chosen number's sector center aligns with top pointer
    function desiredRotationForNumber(num){
      const mid = (num - 1) * sectorAngle;
      let desired = (-90 - mid) % 360;
      if (desired < 0) desired += 360;
      return desired;
    }

    // animate from currentRotation to absoluteTargetRotation (degrees)
    // Added per-sector tick detection and audio playback control.
    function animateSpinTo(absoluteTarget, duration = 4400){
      return new Promise(resolve => {
        const startTime = performance.now();
        const from = currentRotation;
        const delta = absoluteTarget - from;
        // track last sector crossed to play tick once per sector crossing
        let lastSector = Math.floor(((from % 360) + 360) % 360 / sectorAngle);
        function step(now){
          const t = Math.min(1, (now - startTime) / duration);
          const eased = easeOutCubic(t);
          const value = from + delta * eased;
          drawWheel(value);

          // PER-SECTOR TICK: detect sector index and play a short click when crossing into a new sector.
          const mod = ((value % 360) + 360) % 360;
          const sectorIndex = Math.floor(mod / sectorAngle);
          if (sectorIndex !== lastSector){
            lastSector = sectorIndex;
            // small tick for each sector pass (low volume)
            playGeneratedClick({type:'tick', volume:0.035});
          }

          if (t < 1) requestAnimationFrame(step);
          else {
            currentRotation = ((absoluteTarget % 360) + 360) % 360;
            drawWheel(currentRotation);
            resolve();
          }
        }
        requestAnimationFrame(step);
      });
    }

    function updateUi(){
      // history
      historyEl.innerHTML = '';
      if (history.length === 0){
        const d = document.createElement('div');
        d.className = 'small';
        d.style.color = 'var(--muted)';
        d.textContent = 'ÊöÇÊó†ËÆ∞ÂΩï';
        historyEl.appendChild(d);
      } else {
        history.slice(0,7).forEach(n=>{
          const el = document.createElement('div');
          el.className = 'item';
          el.textContent = n;
          historyEl.appendChild(el);
        });
      }
      remainingEl.textContent = Math.max(0, MAX_SPINS - spinCount);
      if (history.length > 0) resultEl.textContent = history[0];
      else resultEl.textContent = '?';
      localStorage.setItem('lucky_history', JSON.stringify(history));
      localStorage.setItem('lucky_spinCount', String(spinCount));
    }

    function showMessage(txt){
      messageEl.textContent = txt || '';
    }

    async function spin(){
      if (isSpinning) return;
      if (spinCount >= MAX_SPINS){
        showMessage('Ê¨°Êï∞Â∑≤Áî®Â∞ΩÔºåËØ∑ÈáçÁΩÆÂêéÂÜçËØï„ÄÇ');
        return;
      }
      const pick = getRandomNumberNotInHistory();
      if (pick === null){
        showMessage('ÊâÄÊúâÂè∑Á†ÅÂ∑≤ÊäΩÂÆåÔºåÂ∑≤Ëá™Âä®Ê∏ÖÁ©∫ËÆ∞ÂΩï„ÄÇ');
        history = []; spinCount = 0; updateUi();
        return;
      }

      // Ensure audio context is created on user gesture to satisfy mobile autoplay rules
      getAudioCtx();

      isSpinning = true;
      spinBtn.disabled = true;
      resetBtn.disabled = true;
      showMessage('');

      // compute target rotation:
      const desiredMod360 = desiredRotationForNumber(pick); // 0..360
      const extraSpins = 6 + Math.floor(Math.random() * 4); // 6-9 full spins
      const currentMod = ((currentRotation % 360) + 360) % 360;
      const deltaToDesired = (desiredMod360 - currentMod + 360) % 360;
      const absoluteTarget = currentRotation + extraSpins * 360 + deltaToDesired;

      // Start spin audio (looped) if available; fall back is ticks only.
      try {
        // resume audio context if suspended (mobile browsers)
        const ac = getAudioCtx();
        if (ac && ac.state === 'suspended') await ac.resume();
        if (spinAudioElem) {
          spinAudioElem.currentTime = 0;
          // try to play; may reject if browser blocked; catch below
          const p = spinAudioElem.play();
          if (p && p.catch) p.catch(() => {
            // fallback: do nothing; ticks will play
          });
        }
      } catch (err) {
        // fallback: nothing to do; ticks will play
      }

      // during spin show placeholder
      resultEl.textContent = '...';
      const duration = 3800 + Math.floor(Math.random() * 1600);
      await animateSpinTo(absoluteTarget, duration);

      // Stop spin audio and play stop audio/impact
      try {
        if (spinAudioElem && !spinAudioElem.paused) {
          spinAudioElem.pause();
          spinAudioElem.currentTime = 0;
        }
      } catch(e){ /* ignore */ }

      // play stop sound (try element first, fallback to generated)
      await tryPlayAudioElem(stopAudioElem, 'stop');

      // finalize: ensure center shows final number clearly
      history.unshift(pick);
      history = history.slice(0, 7);
      spinCount++;
      updateUi();
      showMessage(`ÊÅ≠ÂñúÔºÅÂè∑Á†Å ${pick} Ë¢´ÈÄâ‰∏≠„ÄÇ`);

      isSpinning = false;
      spinBtn.disabled = spinCount >= MAX_SPINS;
      resetBtn.disabled = false;

      if (spinCount >= MAX_SPINS){
        showMessage('‰ªäÊó•Êú∫‰ºöÁî®ÂÆåÔºåÁ•ù‰Ω†Â•ΩËøêÔºÅ');
      }
    }

    function resetGame(){
      if (isSpinning) return;
      history = [];
      spinCount = 0;
      currentRotation = 0;
      drawWheel(currentRotation);
      updateUi();
      showMessage('Â∑≤ÈáçÁΩÆÔºöÂéÜÂè≤‰∏éÊ¨°Êï∞Â∑≤Ê∏ÖÁ©∫„ÄÇ');
    }

    // events
    spinBtn.addEventListener('click', spin);
    resetBtn.addEventListener('click', () => {
      if (confirm('Á°ÆÂÆöË¶ÅÈáçÁΩÆÂéÜÂè≤Âπ∂ÊÅ¢Â§çÊ¨°Êï∞ÂêóÔºü')) resetGame();
    });

    // touch: tap on canvas to spin (mobile friendly)
    canvas.addEventListener('click', () => { spin(); });
    // keyboard
    document.addEventListener('keydown', (e) => { if (e.code === 'Space'){ e.preventDefault(); spin(); } });

    // initialize UI and draw
    updateUi();
    // ensure proper sizing on load after layout
    setTimeout(() => { sizeCanvas(); drawWheel(currentRotation); }, 50);
  </script>
</body>
</html>
